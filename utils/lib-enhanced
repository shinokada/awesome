#!/usr/bin/env bash
# Enhanced utility library for awesome package manager

# Version - Single source of truth for awesome version
AWESOME_VERSION="0.6.0"

# Load configuration
load_config() {
    local config_file="${HOME}/.config/awesome/config"
    if [[ -f "$config_file" ]]; then
        # shellcheck disable=SC1090
        source "$config_file"
    fi

    # Set defaults if not configured
    AWESOME_DIR="${AWESOME_DIR:-$HOME/.local/share/awesome}"
    BIN_DIR="${BIN_DIR:-$HOME/.local/share/bin}"
    LOG_DIR="${LOG_DIR:-$HOME/.local/share/awesome/logs}"
    ENABLE_LOGGING="${ENABLE_LOGGING:-true}"
    GIT_CLONE_DEPTH="${GIT_CLONE_DEPTH:-1}"
    MAX_RETRY_ATTEMPTS="${MAX_RETRY_ATTEMPTS:-3}"
    RETRY_DELAY="${RETRY_DELAY:-2}"
}

# Initialize configuration
load_config

# ============================================================================
# LOGGING FUNCTIONS
# ============================================================================

# Initialize log directory
init_logging() {
    if [[ "$ENABLE_LOGGING" == "true" ]]; then
        mkdir -p "$LOG_DIR"
    fi
}

# Log a message with timestamp
# Usage: log_message "INFO" "Installation completed"
log_message() {
    if [[ "$ENABLE_LOGGING" != "true" ]]; then
        return
    fi

    local level=$1
    local message=$2
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local log_file="$LOG_DIR/awesome.log"

    echo "[$timestamp] [$level] $message" >>"$log_file"
}

# Log operation
# Usage: log_operation "install" "gitstart" "success"
log_operation() {
    local operation=$1
    local package=$2
    local status=$3
    log_message "INFO" "$operation $package - $status"
}

# ============================================================================
# NETWORK & ERROR HANDLING
# ============================================================================

# Check network connectivity
check_network() {
    # Prefer curl for reliability (works in containers/firewalls)
    if command -v curl &>/dev/null; then
        if ! curl -sf --connect-timeout 5 --max-time 10 "https://github.com" -o /dev/null 2>/dev/null; then
            printf "${RED}%s${RESET}\n" "Error: No network connection to GitHub." >&2
            log_message "ERROR" "Network check failed"
            return 1
        fi
    elif ! ping -c 1 github.com &>/dev/null; then
        printf "${RED}%s${RESET}\n" "Error: No network connection to GitHub." >&2
        log_message "ERROR" "Network check failed"
        return 1
    fi
    return 0
}

# Git clone with retry logic
# Usage: git_clone_with_retry "url" "target_dir"
git_clone_with_retry() {
    local url=$1
    local target_dir=$2
    local attempt=1
    local depth_flag=""

    if [[ "$GIT_CLONE_DEPTH" != "0" ]]; then
        depth_flag="--depth=$GIT_CLONE_DEPTH"
    fi

    while [ $attempt -le "$MAX_RETRY_ATTEMPTS" ]; do
        printf "${CYAN}%s${RESET}\n" "Cloning (attempt $attempt/$MAX_RETRY_ATTEMPTS)..."

        # shellcheck disable=SC2086
        if git clone $depth_flag "$url" "$target_dir" 2>/dev/null; then
            log_message "INFO" "Clone succeeded: $url"
            return 0
        fi

        # Cleanup partial clone so retries can succeed
        if [[ -d "$target_dir" ]]; then
            rm -rf "$target_dir"
        fi

        printf "${YELLOW}%s${RESET}\n" "Clone attempt $attempt failed. Retrying in ${RETRY_DELAY}s..."
        log_message "WARN" "Clone attempt $attempt failed: $url"
        ((attempt++))
        sleep "$RETRY_DELAY"
    done

    printf "${RED}%s${RESET}\n" "Failed to clone after $MAX_RETRY_ATTEMPTS attempts." >&2
    log_message "ERROR" "Clone failed after retries: $url"
    return 1
}

# ============================================================================
# PACKAGE MANAGEMENT
# ============================================================================

# Create package manifest
# Usage: create_manifest "package_name" "repo_url" "version"
create_manifest() {
    local package_name=$1
    local repo_url=$2
    local version=${3:-"latest"}
    local manifest_file="$AWESOME_DIR/$package_name/.awesome-manifest"

    mkdir -p "$AWESOME_DIR/$package_name"

    cat >"$manifest_file" <<EOF
{
  "name": "$package_name",
  "version": "$version",
  "repo_url": "$repo_url",
  "install_date": "$(date '+%Y-%m-%d %H:%M:%S')",
  "installed_by": "awesome $AWESOME_VERSION"
}
EOF
    log_message "INFO" "Created manifest for $package_name"
}

# Read package manifest
# Usage: read_manifest "package_name"
read_manifest() {
    local package_name=$1
    local manifest_file="$AWESOME_DIR/$package_name/.awesome-manifest"

    if [[ -f "$manifest_file" ]]; then
        cat "$manifest_file"
    else
        return 1
    fi
}

# Check if package is installed
# Usage: is_installed "package_name"
is_installed() {
    local package_name=$1
    [[ -L "$BIN_DIR/$package_name" ]] && [[ -d "$AWESOME_DIR/$package_name" ]]
}

# ============================================================================
# VALIDATION & HEALTH CHECK
# ============================================================================

# Validate symlink
# Usage: validate_symlink "package_name"
validate_symlink() {
    local package_name=$1
    local link_path="$BIN_DIR/$package_name"

    if [[ ! -L "$link_path" ]]; then
        return 1
    fi

    local target
    target=$(readlink "$link_path") || return 1
    if [[ "$target" != /* ]]; then
        target="$(dirname "$link_path")/$target"
    fi
    if [[ ! -f "$target" ]]; then
        printf "${RED}%s${RESET}\n" "Broken symlink: $package_name -> $target" >&2
        return 1
    fi

    return 0
}

# Find broken symlinks
# Usage: validate_symlinks
validate_symlinks() {
    local broken=()

    while IFS= read -r link; do
        local name=$(basename "$link")
        if ! validate_symlink "$name"; then
            broken+=("$name")
        fi
    done < <(find "$BIN_DIR" -type l 2>/dev/null)

    if [ ${#broken[@]} -gt 0 ]; then
        printf "${YELLOW}%s${RESET}\n" "Found ${#broken[@]} broken symlink(s):"
        printf '%s\n' "${broken[@]}"
        return 1
    fi

    return 0
}

# Check disk space
# Usage: check_disk_space
check_disk_space() {
    local available
    available=$(df -k "$AWESOME_DIR" 2>/dev/null | awk 'NR==2 {print $4}')

    local min_required=102400 # 100MB in KB

    if [[ -n "$available" ]] && [[ "$available" -lt "$min_required" ]]; then
        printf "${YELLOW}%s${RESET}\n" "Warning: Low disk space ($((available / 1024))MB available)"
        return 1
    fi

    return 0
}

# Get package size
# Usage: get_package_size "package_name"
get_package_size() {
    local package_name=$1
    local package_dir="$AWESOME_DIR/$package_name"

    if [[ -d "$package_dir" ]]; then
        du -sh "$package_dir" 2>/dev/null | awk '{print $1}'
    else
        echo "N/A"
    fi
}

# ============================================================================
# BATCH OPERATIONS
# ============================================================================

# List all installed packages
# Usage: list_installed_packages
list_installed_packages() {
    local packages=()

    while IFS= read -r link; do
        local name=$(basename "$link")
        if validate_symlink "$name" 2>/dev/null; then
            packages+=("$name")
        fi
    done < <(find "$BIN_DIR" -type l 2>/dev/null)

    printf '%s\n' "${packages[@]}"
}

# Update all packages
# Usage: update_all_packages
update_all_packages() {
    local packages
    packages=()
    while IFS= read -r pkg; do
        [[ -n "$pkg" ]] && packages+=("$pkg")
    done < <(list_installed_packages)

    if [ ${#packages[@]} -eq 0 ]; then
        printf "${YELLOW}%s${RESET}\n" "No packages installed."
        return
    fi

    printf "${CYAN}%s${RESET}\n" "Updating ${#packages[@]} package(s)..."

    local success=0
    local failed=0

    for package in "${packages[@]}"; do
        printf "\n${BOLD}Updating: %s${RESET}\n" "$package"

        if update_single_package "$package"; then
            ((success++))
        else
            ((failed++))
        fi
    done

    printf "\n${GREEN}%s${RESET}\n" "Update complete: $success succeeded, $failed failed"
    log_message "INFO" "Batch update: $success succeeded, $failed failed"
}

# Update single package (internal function)
update_single_package() {
    local package=$1

    if ! is_installed "$package"; then
        printf "${RED}%s${RESET}\n" "Package $package is not installed."
        return 1
    fi

    local symlink_dir
    symlink_dir="$(myrealpath "$BIN_DIR/$package")"
    local dir="${symlink_dir%/*}"

    if [[ ! -d "$dir/.git" ]]; then
        printf "${YELLOW}%s${RESET}\n" "Skipping $package (not a git repository)"
        return 1
    fi

    if (cd "$dir" && git pull --quiet); then
        printf "${GREEN}%s${RESET}\n" "✓ $package updated"
        log_operation "update" "$package" "success"
        return 0
    else
        printf "${RED}%s${RESET}\n" "✗ $package update failed"
        log_operation "update" "$package" "failed"
        return 1
    fi
}

# ============================================================================
# BACKUP & RESTORE
# ============================================================================

# Export installed packages
# Usage: export_packages [output_file]
export_packages() {
    local output_file=${1:-"$HOME/awesome-packages.txt"}
    local packages
    packages=()
    while IFS= read -r pkg; do
        [[ -n "$pkg" ]] && packages+=("$pkg")
    done < <(list_installed_packages)

    if [ ${#packages[@]} -eq 0 ]; then
        printf "${YELLOW}%s${RESET}\n" "No packages to export."
        return
    fi

    {
        echo "# Awesome Package Manager - Package List"
        echo "# Generated: $(date '+%Y-%m-%d %H:%M:%S')"
        echo ""

        for package in "${packages[@]}"; do
            local symlink_path="$BIN_DIR/$package"
            local real_path
            real_path=$(myrealpath "$symlink_path" 2>/dev/null)

            if [[ -n "$real_path" ]]; then
                local repo_path="${real_path%/*}"
                if [[ -d "$repo_path/.git" ]]; then
                    local remote_url
                    remote_url=$(git -C "$repo_path" config --get remote.origin.url 2>/dev/null)
                    if [[ -n "$remote_url" ]]; then
                        # Extract user/repo from URL
                        if [[ "$remote_url" =~ github.com[:/]([^/]+)/([^/]+)(\.git)?$ ]]; then
                            echo "${BASH_REMATCH[1]}/${BASH_REMATCH[2]%.git}"
                        fi
                    fi
                fi
            fi
        done
    } >"$output_file"

    printf "${GREEN}%s${RESET}\n" "Exported ${#packages[@]} package(s) to: $output_file"
    log_message "INFO" "Exported packages to $output_file"
}

# Import and install packages from file
# Usage: import_packages "input_file"
import_packages() {
    local input_file=$1

    if [[ ! -f "$input_file" ]]; then
        printf "${RED}%s${RESET}\n" "File not found: $input_file"
        return 1
    fi

    printf "${CYAN}%s${RESET}\n" "Importing packages from: $input_file"

    # Read valid package lines once
    local packages=()
    while IFS= read -r pkg; do
        [[ -n "$pkg" ]] && packages+=("$pkg")
    done < <(grep -Ev '^[[:space:]]*(#|$)' "$input_file")

    local total=${#packages[@]}
    if [[ $total -eq 0 ]]; then
        printf "${YELLOW}%s${RESET}\n" "No packages found."
        return 0
    fi

    printf "${CYAN}%s${RESET}\n" "Found $total package(s)"
    echo ""

    local success=0
    local skipped=0
    local failed=0
    local count=0

    for entry in "${packages[@]}"; do
        ((count++))
        printf "${BOLD}[%d/%d] Installing: %s${RESET}\n" \
            "$count" "$total" "$entry"

        # Resolve repo name safely for installed check (avoid repo_script exit)
        local pkg=""
        if [[ "$entry" =~ github\.com[:/]+[^/]+/([^/]+)(\.git)?$ ]]; then
            pkg="${BASH_REMATCH[1]%.git}"
        elif [[ "$entry" =~ ^[^/]+/[^/]+$ ]]; then
            pkg="${entry##*/}"
        else
            printf "${RED}%s${RESET}\n" "  ✗ Invalid entry, skipping"
            log_message "ERROR" "Import invalid entry: $entry"
            ((failed++))
            echo ""
            continue
        fi

        if [[ -n "$pkg" ]] && is_installed "$pkg"; then
            printf "${YELLOW}%s${RESET}\n" "  ⚠ Already installed, skipping"
            log_message "INFO" "Import skipped: $pkg already installed"
            ((skipped++))
            echo ""
            continue
        fi

        # Delegate to the real installer
        if (fn_install "$entry"); then
            ((success++))
        else
            printf "${RED}%s${RESET}\n" "  ✗ Failed"
            log_message "ERROR" "Import failed: $entry"
            ((failed++))
        fi

        echo ""
    done

    printf "\n${BOLD}Import Summary:${RESET}\n"
    printf "  Total: %d\n" "$total"
    printf "  ${GREEN}Installed: %d${RESET}\n" "$success"
    printf "  ${YELLOW}Skipped: %d${RESET}\n" "$skipped"
    printf "  ${RED}Failed: %d${RESET}\n" "$failed"

    log_message "INFO" \
        "Import completed: total=$total installed=$success skipped=$skipped failed=$failed"

    [[ $failed -eq 0 ]]
}

# ============================================================================
# EXISTING FUNCTIONS (keeping your original implementations)
# ============================================================================

# Find repo name and script name
repo_script() {
    local link_arg script_arg
    link_arg=$1
    script_arg=$2
    slash_num=$(echo "$link_arg" | grep -o "/" | wc -l)
    if [[ $link_arg =~ "@" ]]; then
        echo "Please use URL or https, not ssh." >&2
        exit 1
    fi
    if [[ -z $script_arg ]]; then
        if ((slash_num < 1)); then
            echo "Not valid parameter." >&2
            exit 1
        fi
        git_user=$(basename "${link_arg%/*}")
        repo_name=$(basename "${link_arg##*/}" .git)
        script_name=$(basename "${link_arg##*/}" .git)
        if [[ $link_arg =~ https://github.com/ ]]; then
            repo_link="$link_arg"
        else
            repo_link="https://github.com/${link_arg}"
        fi
    else
        if (("$slash_num" == 1)); then
            git_user="${link_arg%/*}"
            repo_name="${link_arg##*/}"
            script_name="$script_arg"
            repo_link="https://github.com/${link_arg}"
        else
            git_user=$(basename "${link_arg%/*}")
            repo_name=$(basename "$link_arg" .git)
            script_name="$script_arg"
            repo_link="$link_arg"
        fi
    fi
}

checkOrmkdir() {
    if [[ -z $1 ]]; then
        echo "Specify the directory." >&2
        exit 1
    fi
    if [[ ! -d $1 ]]; then
        mkdir -p "$1"
        echo "$1 directory is created." >&1
        return 0
    else
        return 0
    fi
}

checkDir() {
    if [[ -d $1 ]]; then
        echo 1
    else
        echo 0
    fi
}

checkFile() {
    if [[ -f $1 ]]; then
        return 0
    else
        return 1
    fi
}

symlink_names() {
    find "$1" -type l -exec basename -a {} +
    return 0
}

check_link() {
    if [[ -L "$2/$1" ]]; then
        return 0
    else
        echo "There is no $1 link in $2 dir."
        exit 1
    fi
}

src_path() {
    src_path=$1
    echo "${src_path%/*}"
}

check_cmd() {
    if [ ! "$(command -v "$1")" ]; then
        echo "Please install $1" >&2
        exit 1
    fi
}

alias_check() {
    if type "$1" &>/dev/null; then
        return 1
    else
        return 0
    fi
}

create_symlink() {
    ln -sf "$1/$2/$3" "$4/$3"
    echo "Created a symlink."
    log_operation "symlink" "$3" "created"
    return 0
}

create_alias() {
    ln -sf "$1/$2/$3" "$4/$5"
    echo "Created a symlink."
    log_operation "alias" "$5" "created"
    return 0
}

same_src_path() {
    src_path=$1
    bin_dir=$2
    find "$bin_dir" -type l -ilname "*${src_path}*" | wc -l
}

open_url() {
    if command -v python &>/dev/null; then
        python -m webbrowser https://github.com/shinokada/awesome
    elif command -v python3 &>/dev/null; then
        python3 -m webbrowser https://github.com/shinokada/awesome
    else
        printf "${YELLOW}%s${RESET}\n" "Please open: https://github.com/shinokada/awesome"
    fi
}

show_symlinks() {
    ls -l "$BIN_DIR"
}

first() {
    item=$1
    echo "${item%/*}"
}

second() {
    item=$1
    echo "${item##*/}"
}

no_symlink() {
    if [[ -L "$2/$1" ]]; then
        return 1
    else
        return 0
    fi
}

slashes() {
    echo "$1" | grep -o "/" | wc -l | tr -d '[:space:]'
}

myrealpath() {
    local LINK REALPATH
    local OURPWD=$PWD
    cd "$(dirname "$1")" || return 1
    LINK=$(readlink "$(basename "$1")")
    while [ "$LINK" ]; do
        cd "$(dirname "$LINK")" || return 1
        LINK=$(readlink "$(basename "$LINK")")
    done
    REALPATH="$PWD/$(basename "$1")"
    cd "$OURPWD" || return 1
    echo "$REALPATH"
}

# ============================================================================
# COLOR DEFINITIONS
# ============================================================================

ESC=$(printf '\033')
RESET="${ESC}[0m"

BOLD="${ESC}[1m"
FAINT="${ESC}[2m"
ITALIC="${ESC}[3m"
UNDERLINE="${ESC}[4m"
BLINK="${ESC}[5m"
FAST_BLINK="${ESC}[6m"
REVERSE="${ESC}[7m"
CONCEAL="${ESC}[8m"
STRIKE="${ESC}[9m"

GOTHIC="${ESC}[20m"
DOUBLE_UNDERLINE="${ESC}[21m"
NORMAL="${ESC}[22m"
NO_ITALIC="${ESC}[23m"
NO_UNDERLINE="${ESC}[24m"
NO_BLINK="${ESC}[25m"
NO_REVERSE="${ESC}[27m"
NO_CONCEAL="${ESC}[28m"
NO_STRIKE="${ESC}[29m"

BLACK="${ESC}[30m"
RED="${ESC}[31m"
GREEN="${ESC}[32m"
YELLOW="${ESC}[33m"
BLUE="${ESC}[34m"
MAGENTA="${ESC}[35m"
CYAN="${ESC}[36m"
WHITE="${ESC}[37m"
DEFAULT="${ESC}[39m"

BG_BLACK="${ESC}[40m"
BG_RED="${ESC}[41m"
BG_GREEN="${ESC}[42m"
BG_YELLOW="${ESC}[43m"
BG_BLUE="${ESC}[44m"
BG_MAGENTA="${ESC}[45m"
BG_CYAN="${ESC}[46m"
BG_WHITE="${ESC}[47m"
BG_DEFAULT="${ESC}[49m"

function bannerColor() {
    case ${2} in
    black) color=0 ;;
    red) color=1 ;;
    green) color=2 ;;
    yellow) color=3 ;;
    blue) color=4 ;;
    magenta) color=5 ;;
    cyan) color=6 ;;
    white) color=7 ;;
    *)
        echo "color is not set"
        exit 1
        ;;
    esac

    local msg="${3} ${1} ${3}"
    local edge=$(echo "${msg}" | sed "s/./${3}/g")
    tput setaf ${color}
    tput bold
    echo "${edge}"
    echo "${msg}"
    echo "${edge}"
    tput sgr 0
    echo
}

# Initialize logging when lib is sourced
init_logging
